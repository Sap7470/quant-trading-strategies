# -*- coding: utf-8 -*-
"""Finance- 1 (Mean Reversion & Momentum).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VCqziMpSMp0DfqUSzJV4xkgouQcCn6Fw

# **Algorithmic Trading: Mean Reversion & Momentum Strategies**
This notebook implements and backtests two trading strategies:
- **Momentum Strategy (Moving Average Crossover)**
- **Mean Reversion Strategy (Bollinger Bands)**


### **Performance Metrics Used**:
- **Sharpe Ratio**: Measures risk-adjusted returns.
- **Max Drawdown**: The worst peak-to-trough drop.

---
"""

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt

#Download Stock Data
stock = "AAPL"
df = yf.download(stock, start="2020-01-01", end="2025-01-01")

plt.figure(figsize= (12,8))
plt.plot(df.index, df['Close'], label= 'Apple Closing Price', color= 'b')
plt.xlabel('Date')
plt.ylabel('Closing Price ($)')
plt.legend()
plt.show()

"""# **1. Momentum Strategy (Moving Average Crossover)**
The Momentum Strategy follows the trend using two moving averages.

**Trading Rules:**
- **BUY** when the 50-day SMA crosses above the 200-day SMA (Golden Cross).
- **SELL** when the 50-day SMA crosses below the 200-day SMA (Death Cross).

"""

# Flatten MultiIndex Columns (Fix for MultiIndex Issue)
df.columns = ['_'.join(col).strip() if isinstance(col, tuple) else col for col in df.columns]

df['SMA50']= df[f"Close_{stock}"].rolling(50).mean()
df['SMA200']= df[f"Close_{stock}"].rolling(200).mean()

plt.figure(figsize= (12,8))
plt.plot(df.index, df[f"Close_{stock}"], label= 'Apple Closing Price', color= 'b')
plt.plot(df.index, df['SMA50'], label= '50 Day SMA', color= 'r')
plt.plot(df.index, df['SMA200'], label= '200 Day SMA', color= 'g')
plt.xlabel('Date')
plt.ylabel('Closing Price ($)')
plt.title('Apple Closing Price and SMA')
plt.legend()
plt.show()

df['Signal_Trend_Following']= 0
df.loc[df['SMA50'] > df['SMA200'], 'Signal_Trend_Following']= 1 # 1: Buy, -1: Sell
df.loc[df['SMA50'] < df['SMA200'], 'Signal_Trend_Following']= -1
df['Trade_Signal_Trend_Following']= df['Signal_Trend_Following'].shift(1)

plt.figure(figsize= (12,8))
plt.plot(df.index, df[f"Close_{stock}"], label= 'Apple Closing Price', color= 'b')
plt.plot(df.index, df['SMA50'], label= '50 Day SMA', color= 'r')
plt.plot(df.index, df['SMA200'], label= '200 Day SMA', color= 'g')

plt.scatter(df.index[df['Signal_Trend_Following'] ==1], df[f"Close_{stock}"][df['Signal_Trend_Following'] ==1], label= 'Buy', color= 'g', marker= '^', alpha= 1)
plt.scatter(df.index[df['Signal_Trend_Following'] ==-1], df[f"Close_{stock}"][df['Signal_Trend_Following'] ==-1], label= 'Sell', color= 'r', marker= 'v', alpha= 1)

plt.xlabel('Date')
plt.ylabel('Closing Price ($)')
plt.title('Apple Closing Price, SMA and Crossover Strategy with Buy/ Sell Signals')
plt.legend()
plt.show()

# Assume Initial Capital of $10,000
initial_capital = 10000

# Daily Returns
df["Returns_Trend_Following"] = df[f"Close_{stock}"].pct_change()

# Fill missing trade signals before multiplication
df["Trade_Signal_Trend_Following"] = df["Signal_Trend_Following"].shift(1).fillna(0)

# Portfolio Value Calculation
df["Strategy_Returns_Trend_Following"] = df["Returns_Trend_Following"] * df["Trade_Signal_Trend_Following"]
df["Cumulative_Strategy_Trend_Following"] = (1 + df["Strategy_Returns_Trend_Following"]).cumprod() * initial_capital
df["Cumulative_Market_Trend_Following"] = (1 + df["Returns_Trend_Following"]).cumprod() * initial_capital

# Plot Portfolio vs Market
plt.figure(figsize=(12,6))
plt.plot(df.index, df["Cumulative_Strategy_Trend_Following"], label="Strategy Performance (Trend Following)", color="green")
plt.plot(df.index, df["Cumulative_Market_Trend_Following"], label="Market Performance", color="blue", linestyle="dashed")
plt.xlabel("Date")
plt.ylabel("Portfolio Value ($)")
plt.title("Backtest: Moving Average Crossover Strategy vs Market")
plt.legend()
plt.show()

# Debugging: Print Final Portfolio Values
print("Final Portfolio Value (Strategy): $", round(df["Cumulative_Strategy_Trend_Following"].iloc[-1], 2))
print("Final Portfolio Value (Market): $", round(df["Cumulative_Market_Trend_Following"].iloc[-1], 2))

# Compute Key Metrics
sharpe_ratio_trend = df["Strategy_Returns_Trend_Following"].mean() / df["Strategy_Returns_Trend_Following"].std() * np.sqrt(252)  # Annualized
max_drawdown_trend = (df["Cumulative_Strategy_Trend_Following"] / df["Cumulative_Strategy_Trend_Following"].cummax() - 1).min()

# Print Results
print(f"Sharpe Ratio (Trend Following): {sharpe_ratio_trend:.2f}")  # Sharpe Ratio > 1 → Good risk-adjusted return.
print(f"Max Drawdown (Trend Following): {max_drawdown_trend:.2%}")  # Max Drawdown → Maximum loss from peak to trough.

"""# **2. Mean Reversion Strategy (Bollinger Bands)**
The Mean Reversion Strategy assumes that prices tend to revert to their mean.

**Trading Rules:**
- **BUY** when the price is below the lower Bollinger Band.
- **SELL** when the price is above the upper Bollinger Band.
"""

# Step 2: Compute Bollinger Bands
df["SMA20"] = df[f"Close_{stock}"].rolling(window=20, min_periods=20).mean()
df["Rolling_std"] = df[f"Close_{stock}"].rolling(window=20, min_periods=20).std()
df["Upper_Band"] = df["SMA20"] + (2 * df["Rolling_std"])
df["Lower_Band"] = df["SMA20"] - (2 * df["Rolling_std"])

# Step 3: Drop NaN values safely
df.dropna(subset=["SMA20", "Upper_Band", "Lower_Band"], inplace=True)
df.reset_index(drop=True, inplace=True)

# Step 4: Initialize & Assign Buy/Sell Signals
df["Signal_Mean_Reversal"] = np.where(df[f"Close_{stock}"] < df["Lower_Band"], 1,
                                      np.where(df[f"Close_{stock}"] > df["Upper_Band"], -1, 0))

# Step 5: Backtest Mean Reversion Strategy
initial_capital = 10000  # $10,000 initial capital
df["Returns"] = df[f"Close_{stock}"].pct_change()
df["Strategy_Returns"] = df["Returns"] * df["Signal_Mean_Reversal"].shift(1)
df["Cumulative_Strategy"] = (1 + df["Strategy_Returns"]).cumprod() * initial_capital
df["Cumulative_Market"] = (1 + df["Returns"]).cumprod() * initial_capital

# Step 6: Plot Bollinger Bands & Trade Signals
plt.figure(figsize=(12,6))
plt.plot(df.index, df[f"Close_{stock}"], label="AAPL Close Price", color="blue", alpha=0.6)
plt.plot(df.index, df["Upper_Band"], label="Upper Band", color="red", linestyle="dashed")
plt.plot(df.index, df["Lower_Band"], label="Lower Band", color="green", linestyle="dashed")
plt.scatter(df.index[df["Signal_Mean_Reversal"] == 1], df[f"Close_{stock}"][df["Signal_Mean_Reversal"] == 1],
            marker="^", color="green", label="Buy Signal", alpha=1)
plt.scatter(df.index[df["Signal_Mean_Reversal"] == -1], df[f"Close_{stock}"][df["Signal_Mean_Reversal"] == -1],
            marker="v", color="red", label="Sell Signal", alpha=1)
plt.xlabel("Date")
plt.ylabel("Price ($)")
plt.title("Bollinger Bands Mean Reversion Strategy")
plt.legend()
plt.show()

# Step 7: Performance Metrics
sharpe_ratio = df["Strategy_Returns"].mean() / df["Strategy_Returns"].std() * np.sqrt(252)
max_drawdown = (df["Cumulative_Strategy"] / df["Cumulative_Strategy"].cummax() - 1).min()
print(f"Mean Reversion Strategy - Sharpe Ratio: {sharpe_ratio:.2f}")
print(f"Mean Reversion Strategy - Max Drawdown: {max_drawdown:.2%}")

"""# **3. Strategy Performance Comparison**
We compare the final portfolio value, Sharpe Ratio, and Max Drawdown.

"""

# Compute Sharpe Ratio & Max Drawdown for Momentum Strategy
sharpe_momentum = df["Strategy_Returns_Trend_Following"].mean() / df["Strategy_Returns_Trend_Following"].std() * np.sqrt(252)
max_drawdown_momentum = (df["Cumulative_Strategy_Trend_Following"] / df["Cumulative_Strategy_Trend_Following"].cummax() - 1).min()

# Print Results
print(f"Sharpe Ratio (Mean Reversion): {sharpe_ratio:.2f}")
print(f"Max Drawdown (Mean Reversion): {max_drawdown:.2%}")

print(f"Sharpe Ratio (Momentum Strategy): {sharpe_momentum:.2f}")
print(f"Max Drawdown (Momentum Strategy): {max_drawdown_momentum:.2%}")


from tabulate import tabulate

comparison_data = [
    ["Mean Reversion", sharpe_ratio, max_drawdown, df["Cumulative_Strategy"].iloc[-1]],
    ["Momentum Strategy", sharpe_momentum, max_drawdown_momentum, df["Cumulative_Strategy_Trend_Following"].iloc[-1]]
]

print(tabulate(comparison_data, headers=["Strategy", "Sharpe Ratio", "Max Drawdown", "Final Portfolio Value ($)"]))

"""# ** Conclusion**
## **1. Performance Summary**
- The **Mean Reversion Strategy (Bollinger Bands)** had a **Sharpe Ratio of 0.33** and a **Max Drawdown of -9.24%**, meaning it had **moderate risk-adjusted returns** with a controlled level of downside risk.
- The **Momentum Strategy (Moving Average Crossover)** had a **Sharpe Ratio of only 0.04** and a **Max Drawdown of -50.78%**, meaning it **significantly underperformed** with **high volatility and deep losses**.

## **2. Portfolio Growth Comparison**
- The **final portfolio value for Mean Reversion was $11,589.40**, resulting in a **9.40% loss** from the initial **10,000 dollars**.

- The **Momentum Strategy ended at $9,060.15**, resulting in a **9.40% loss**, underperforming both the Mean Reversion Strategy and the overall market.

## **3. Key Takeaways**
- The **Mean Reversion Strategy** was more **stable and profitable**, making it a **better choice for range-bound market conditions**.
- The **Momentum Strategy** struggled due to **false breakouts and whipsaws**, leading to a **high drawdown** and poor performance.
- **Market conditions matter**: The success of either strategy **depends on market trends**. If the market had trended strongly, the momentum strategy might have performed better.

## **4. Final Thoughts**
- Based on this backtest, the **Mean Reversion Strategy** is the preferred approach for **risk-conscious traders** in relatively stable markets.
- The **Momentum Strategy** requires improvements, such as adding **filters to avoid false breakouts** or **combining it with other indicators** like RSI.
- Future work could explore **hybrid strategies**, combining **mean reversion signals with momentum confirmation** for better overall performance.

"""

